// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qa.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_qa_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_qa_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_qa_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_qa_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_qa_2eproto;
namespace qa {
class QAReply;
class QAReplyDefaultTypeInternal;
extern QAReplyDefaultTypeInternal _QAReply_default_instance_;
class QAReply2;
class QAReply2DefaultTypeInternal;
extern QAReply2DefaultTypeInternal _QAReply2_default_instance_;
class QARequest;
class QARequestDefaultTypeInternal;
extern QARequestDefaultTypeInternal _QARequest_default_instance_;
class QARequest2;
class QARequest2DefaultTypeInternal;
extern QARequest2DefaultTypeInternal _QARequest2_default_instance_;
class docFreqVector;
class docFreqVectorDefaultTypeInternal;
extern docFreqVectorDefaultTypeInternal _docFreqVector_default_instance_;
class docFreqVectorList;
class docFreqVectorListDefaultTypeInternal;
extern docFreqVectorListDefaultTypeInternal _docFreqVectorList_default_instance_;
class docIdVector;
class docIdVectorDefaultTypeInternal;
extern docIdVectorDefaultTypeInternal _docIdVector_default_instance_;
class docIdVectorList;
class docIdVectorListDefaultTypeInternal;
extern docIdVectorListDefaultTypeInternal _docIdVectorList_default_instance_;
class sentenceVector;
class sentenceVectorDefaultTypeInternal;
extern sentenceVectorDefaultTypeInternal _sentenceVector_default_instance_;
class sentenceVectorList;
class sentenceVectorListDefaultTypeInternal;
extern sentenceVectorListDefaultTypeInternal _sentenceVectorList_default_instance_;
class wordVector;
class wordVectorDefaultTypeInternal;
extern wordVectorDefaultTypeInternal _wordVector_default_instance_;
class wordVectorList;
class wordVectorListDefaultTypeInternal;
extern wordVectorListDefaultTypeInternal _wordVectorList_default_instance_;
}  // namespace qa
PROTOBUF_NAMESPACE_OPEN
template<> ::qa::QAReply* Arena::CreateMaybeMessage<::qa::QAReply>(Arena*);
template<> ::qa::QAReply2* Arena::CreateMaybeMessage<::qa::QAReply2>(Arena*);
template<> ::qa::QARequest* Arena::CreateMaybeMessage<::qa::QARequest>(Arena*);
template<> ::qa::QARequest2* Arena::CreateMaybeMessage<::qa::QARequest2>(Arena*);
template<> ::qa::docFreqVector* Arena::CreateMaybeMessage<::qa::docFreqVector>(Arena*);
template<> ::qa::docFreqVectorList* Arena::CreateMaybeMessage<::qa::docFreqVectorList>(Arena*);
template<> ::qa::docIdVector* Arena::CreateMaybeMessage<::qa::docIdVector>(Arena*);
template<> ::qa::docIdVectorList* Arena::CreateMaybeMessage<::qa::docIdVectorList>(Arena*);
template<> ::qa::sentenceVector* Arena::CreateMaybeMessage<::qa::sentenceVector>(Arena*);
template<> ::qa::sentenceVectorList* Arena::CreateMaybeMessage<::qa::sentenceVectorList>(Arena*);
template<> ::qa::wordVector* Arena::CreateMaybeMessage<::qa::wordVector>(Arena*);
template<> ::qa::wordVectorList* Arena::CreateMaybeMessage<::qa::wordVectorList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace qa {

// ===================================================================

class QARequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.QARequest) */ {
 public:
  QARequest();
  virtual ~QARequest();

  QARequest(const QARequest& from);
  QARequest(QARequest&& from) noexcept
    : QARequest() {
    *this = ::std::move(from);
  }

  inline QARequest& operator=(const QARequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QARequest& operator=(QARequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QARequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QARequest* internal_default_instance() {
    return reinterpret_cast<const QARequest*>(
               &_QARequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(QARequest* other);
  friend void swap(QARequest& a, QARequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QARequest* New() const final {
    return CreateMaybeMessage<QARequest>(nullptr);
  }

  QARequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QARequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QARequest& from);
  void MergeFrom(const QARequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QARequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.QARequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filepath = 1;
  void clear_filepath();
  static const int kFilepathFieldNumber = 1;
  const std::string& filepath() const;
  void set_filepath(const std::string& value);
  void set_filepath(std::string&& value);
  void set_filepath(const char* value);
  void set_filepath(const char* value, size_t size);
  std::string* mutable_filepath();
  std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);

  // @@protoc_insertion_point(class_scope:qa.QARequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class QAReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.QAReply) */ {
 public:
  QAReply();
  virtual ~QAReply();

  QAReply(const QAReply& from);
  QAReply(QAReply&& from) noexcept
    : QAReply() {
    *this = ::std::move(from);
  }

  inline QAReply& operator=(const QAReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline QAReply& operator=(QAReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QAReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QAReply* internal_default_instance() {
    return reinterpret_cast<const QAReply*>(
               &_QAReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(QAReply* other);
  friend void swap(QAReply& a, QAReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QAReply* New() const final {
    return CreateMaybeMessage<QAReply>(nullptr);
  }

  QAReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QAReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QAReply& from);
  void MergeFrom(const QAReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QAReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.QAReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool isOk = 1;
  void clear_isok();
  static const int kIsOkFieldNumber = 1;
  bool isok() const;
  void set_isok(bool value);

  // @@protoc_insertion_point(class_scope:qa.QAReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool isok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class QARequest2 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.QARequest2) */ {
 public:
  QARequest2();
  virtual ~QARequest2();

  QARequest2(const QARequest2& from);
  QARequest2(QARequest2&& from) noexcept
    : QARequest2() {
    *this = ::std::move(from);
  }

  inline QARequest2& operator=(const QARequest2& from) {
    CopyFrom(from);
    return *this;
  }
  inline QARequest2& operator=(QARequest2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QARequest2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QARequest2* internal_default_instance() {
    return reinterpret_cast<const QARequest2*>(
               &_QARequest2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(QARequest2* other);
  friend void swap(QARequest2& a, QARequest2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QARequest2* New() const final {
    return CreateMaybeMessage<QARequest2>(nullptr);
  }

  QARequest2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QARequest2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QARequest2& from);
  void MergeFrom(const QARequest2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QARequest2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.QARequest2";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);

  // @@protoc_insertion_point(class_scope:qa.QARequest2)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class QAReply2 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.QAReply2) */ {
 public:
  QAReply2();
  virtual ~QAReply2();

  QAReply2(const QAReply2& from);
  QAReply2(QAReply2&& from) noexcept
    : QAReply2() {
    *this = ::std::move(from);
  }

  inline QAReply2& operator=(const QAReply2& from) {
    CopyFrom(from);
    return *this;
  }
  inline QAReply2& operator=(QAReply2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QAReply2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QAReply2* internal_default_instance() {
    return reinterpret_cast<const QAReply2*>(
               &_QAReply2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(QAReply2* other);
  friend void swap(QAReply2& a, QAReply2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QAReply2* New() const final {
    return CreateMaybeMessage<QAReply2>(nullptr);
  }

  QAReply2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QAReply2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QAReply2& from);
  void MergeFrom(const QAReply2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QAReply2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.QAReply2";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:qa.QAReply2)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class wordVector :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.wordVector) */ {
 public:
  wordVector();
  virtual ~wordVector();

  wordVector(const wordVector& from);
  wordVector(wordVector&& from) noexcept
    : wordVector() {
    *this = ::std::move(from);
  }

  inline wordVector& operator=(const wordVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline wordVector& operator=(wordVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const wordVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const wordVector* internal_default_instance() {
    return reinterpret_cast<const wordVector*>(
               &_wordVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(wordVector* other);
  friend void swap(wordVector& a, wordVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline wordVector* New() const final {
    return CreateMaybeMessage<wordVector>(nullptr);
  }

  wordVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<wordVector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const wordVector& from);
  void MergeFrom(const wordVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(wordVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.wordVector";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float score = 2;
  int score_size() const;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  float score(int index) const;
  void set_score(int index, float value);
  void add_score(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      score() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_score();

  // string word = 1;
  void clear_word();
  static const int kWordFieldNumber = 1;
  const std::string& word() const;
  void set_word(const std::string& value);
  void set_word(std::string&& value);
  void set_word(const char* value);
  void set_word(const char* value, size_t size);
  std::string* mutable_word();
  std::string* release_word();
  void set_allocated_word(std::string* word);

  // @@protoc_insertion_point(class_scope:qa.wordVector)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > score_;
  mutable std::atomic<int> _score_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr word_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class wordVectorList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.wordVectorList) */ {
 public:
  wordVectorList();
  virtual ~wordVectorList();

  wordVectorList(const wordVectorList& from);
  wordVectorList(wordVectorList&& from) noexcept
    : wordVectorList() {
    *this = ::std::move(from);
  }

  inline wordVectorList& operator=(const wordVectorList& from) {
    CopyFrom(from);
    return *this;
  }
  inline wordVectorList& operator=(wordVectorList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const wordVectorList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const wordVectorList* internal_default_instance() {
    return reinterpret_cast<const wordVectorList*>(
               &_wordVectorList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(wordVectorList* other);
  friend void swap(wordVectorList& a, wordVectorList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline wordVectorList* New() const final {
    return CreateMaybeMessage<wordVectorList>(nullptr);
  }

  wordVectorList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<wordVectorList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const wordVectorList& from);
  void MergeFrom(const wordVectorList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(wordVectorList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.wordVectorList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qa.wordVector wVec = 1;
  int wvec_size() const;
  void clear_wvec();
  static const int kWVecFieldNumber = 1;
  ::qa::wordVector* mutable_wvec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::wordVector >*
      mutable_wvec();
  const ::qa::wordVector& wvec(int index) const;
  ::qa::wordVector* add_wvec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::wordVector >&
      wvec() const;

  // @@protoc_insertion_point(class_scope:qa.wordVectorList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::wordVector > wvec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class sentenceVector :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.sentenceVector) */ {
 public:
  sentenceVector();
  virtual ~sentenceVector();

  sentenceVector(const sentenceVector& from);
  sentenceVector(sentenceVector&& from) noexcept
    : sentenceVector() {
    *this = ::std::move(from);
  }

  inline sentenceVector& operator=(const sentenceVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline sentenceVector& operator=(sentenceVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const sentenceVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sentenceVector* internal_default_instance() {
    return reinterpret_cast<const sentenceVector*>(
               &_sentenceVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(sentenceVector* other);
  friend void swap(sentenceVector& a, sentenceVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline sentenceVector* New() const final {
    return CreateMaybeMessage<sentenceVector>(nullptr);
  }

  sentenceVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sentenceVector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const sentenceVector& from);
  void MergeFrom(const sentenceVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sentenceVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.sentenceVector";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float score = 1;
  int score_size() const;
  void clear_score();
  static const int kScoreFieldNumber = 1;
  float score(int index) const;
  void set_score(int index, float value);
  void add_score(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      score() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_score();

  // @@protoc_insertion_point(class_scope:qa.sentenceVector)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > score_;
  mutable std::atomic<int> _score_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class sentenceVectorList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.sentenceVectorList) */ {
 public:
  sentenceVectorList();
  virtual ~sentenceVectorList();

  sentenceVectorList(const sentenceVectorList& from);
  sentenceVectorList(sentenceVectorList&& from) noexcept
    : sentenceVectorList() {
    *this = ::std::move(from);
  }

  inline sentenceVectorList& operator=(const sentenceVectorList& from) {
    CopyFrom(from);
    return *this;
  }
  inline sentenceVectorList& operator=(sentenceVectorList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const sentenceVectorList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sentenceVectorList* internal_default_instance() {
    return reinterpret_cast<const sentenceVectorList*>(
               &_sentenceVectorList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(sentenceVectorList* other);
  friend void swap(sentenceVectorList& a, sentenceVectorList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline sentenceVectorList* New() const final {
    return CreateMaybeMessage<sentenceVectorList>(nullptr);
  }

  sentenceVectorList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sentenceVectorList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const sentenceVectorList& from);
  void MergeFrom(const sentenceVectorList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sentenceVectorList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.sentenceVectorList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qa.sentenceVector sVec = 1;
  int svec_size() const;
  void clear_svec();
  static const int kSVecFieldNumber = 1;
  ::qa::sentenceVector* mutable_svec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::sentenceVector >*
      mutable_svec();
  const ::qa::sentenceVector& svec(int index) const;
  ::qa::sentenceVector* add_svec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::sentenceVector >&
      svec() const;

  // @@protoc_insertion_point(class_scope:qa.sentenceVectorList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::sentenceVector > svec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class docFreqVector :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.docFreqVector) */ {
 public:
  docFreqVector();
  virtual ~docFreqVector();

  docFreqVector(const docFreqVector& from);
  docFreqVector(docFreqVector&& from) noexcept
    : docFreqVector() {
    *this = ::std::move(from);
  }

  inline docFreqVector& operator=(const docFreqVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline docFreqVector& operator=(docFreqVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const docFreqVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const docFreqVector* internal_default_instance() {
    return reinterpret_cast<const docFreqVector*>(
               &_docFreqVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(docFreqVector* other);
  friend void swap(docFreqVector& a, docFreqVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline docFreqVector* New() const final {
    return CreateMaybeMessage<docFreqVector>(nullptr);
  }

  docFreqVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<docFreqVector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const docFreqVector& from);
  void MergeFrom(const docFreqVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(docFreqVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.docFreqVector";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string word = 1;
  void clear_word();
  static const int kWordFieldNumber = 1;
  const std::string& word() const;
  void set_word(const std::string& value);
  void set_word(std::string&& value);
  void set_word(const char* value);
  void set_word(const char* value, size_t size);
  std::string* mutable_word();
  std::string* release_word();
  void set_allocated_word(std::string* word);

  // float freq = 2;
  void clear_freq();
  static const int kFreqFieldNumber = 2;
  float freq() const;
  void set_freq(float value);

  // @@protoc_insertion_point(class_scope:qa.docFreqVector)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr word_;
  float freq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class docFreqVectorList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.docFreqVectorList) */ {
 public:
  docFreqVectorList();
  virtual ~docFreqVectorList();

  docFreqVectorList(const docFreqVectorList& from);
  docFreqVectorList(docFreqVectorList&& from) noexcept
    : docFreqVectorList() {
    *this = ::std::move(from);
  }

  inline docFreqVectorList& operator=(const docFreqVectorList& from) {
    CopyFrom(from);
    return *this;
  }
  inline docFreqVectorList& operator=(docFreqVectorList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const docFreqVectorList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const docFreqVectorList* internal_default_instance() {
    return reinterpret_cast<const docFreqVectorList*>(
               &_docFreqVectorList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(docFreqVectorList* other);
  friend void swap(docFreqVectorList& a, docFreqVectorList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline docFreqVectorList* New() const final {
    return CreateMaybeMessage<docFreqVectorList>(nullptr);
  }

  docFreqVectorList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<docFreqVectorList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const docFreqVectorList& from);
  void MergeFrom(const docFreqVectorList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(docFreqVectorList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.docFreqVectorList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qa.docFreqVector idf = 1;
  int idf_size() const;
  void clear_idf();
  static const int kIdfFieldNumber = 1;
  ::qa::docFreqVector* mutable_idf(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docFreqVector >*
      mutable_idf();
  const ::qa::docFreqVector& idf(int index) const;
  ::qa::docFreqVector* add_idf();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docFreqVector >&
      idf() const;

  // @@protoc_insertion_point(class_scope:qa.docFreqVectorList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docFreqVector > idf_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class docIdVector :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.docIdVector) */ {
 public:
  docIdVector();
  virtual ~docIdVector();

  docIdVector(const docIdVector& from);
  docIdVector(docIdVector&& from) noexcept
    : docIdVector() {
    *this = ::std::move(from);
  }

  inline docIdVector& operator=(const docIdVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline docIdVector& operator=(docIdVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const docIdVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const docIdVector* internal_default_instance() {
    return reinterpret_cast<const docIdVector*>(
               &_docIdVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(docIdVector* other);
  friend void swap(docIdVector& a, docIdVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline docIdVector* New() const final {
    return CreateMaybeMessage<docIdVector>(nullptr);
  }

  docIdVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<docIdVector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const docIdVector& from);
  void MergeFrom(const docIdVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(docIdVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.docIdVector";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 docId = 2;
  int docid_size() const;
  void clear_docid();
  static const int kDocIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 docid(int index) const;
  void set_docid(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_docid(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      docid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_docid();

  // string word = 1;
  void clear_word();
  static const int kWordFieldNumber = 1;
  const std::string& word() const;
  void set_word(const std::string& value);
  void set_word(std::string&& value);
  void set_word(const char* value);
  void set_word(const char* value, size_t size);
  std::string* mutable_word();
  std::string* release_word();
  void set_allocated_word(std::string* word);

  // @@protoc_insertion_point(class_scope:qa.docIdVector)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > docid_;
  mutable std::atomic<int> _docid_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr word_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// -------------------------------------------------------------------

class docIdVectorList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qa.docIdVectorList) */ {
 public:
  docIdVectorList();
  virtual ~docIdVectorList();

  docIdVectorList(const docIdVectorList& from);
  docIdVectorList(docIdVectorList&& from) noexcept
    : docIdVectorList() {
    *this = ::std::move(from);
  }

  inline docIdVectorList& operator=(const docIdVectorList& from) {
    CopyFrom(from);
    return *this;
  }
  inline docIdVectorList& operator=(docIdVectorList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const docIdVectorList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const docIdVectorList* internal_default_instance() {
    return reinterpret_cast<const docIdVectorList*>(
               &_docIdVectorList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(docIdVectorList* other);
  friend void swap(docIdVectorList& a, docIdVectorList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline docIdVectorList* New() const final {
    return CreateMaybeMessage<docIdVectorList>(nullptr);
  }

  docIdVectorList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<docIdVectorList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const docIdVectorList& from);
  void MergeFrom(const docIdVectorList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(docIdVectorList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qa.docIdVectorList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qa_2eproto);
    return ::descriptor_table_qa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qa.docIdVector dIdVec = 1;
  int didvec_size() const;
  void clear_didvec();
  static const int kDIdVecFieldNumber = 1;
  ::qa::docIdVector* mutable_didvec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docIdVector >*
      mutable_didvec();
  const ::qa::docIdVector& didvec(int index) const;
  ::qa::docIdVector* add_didvec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docIdVector >&
      didvec() const;

  // @@protoc_insertion_point(class_scope:qa.docIdVectorList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docIdVector > didvec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qa_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// QARequest

// string filepath = 1;
inline void QARequest::clear_filepath() {
  filepath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& QARequest::filepath() const {
  // @@protoc_insertion_point(field_get:qa.QARequest.filepath)
  return filepath_.GetNoArena();
}
inline void QARequest::set_filepath(const std::string& value) {
  
  filepath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qa.QARequest.filepath)
}
inline void QARequest::set_filepath(std::string&& value) {
  
  filepath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qa.QARequest.filepath)
}
inline void QARequest::set_filepath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filepath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qa.QARequest.filepath)
}
inline void QARequest::set_filepath(const char* value, size_t size) {
  
  filepath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qa.QARequest.filepath)
}
inline std::string* QARequest::mutable_filepath() {
  
  // @@protoc_insertion_point(field_mutable:qa.QARequest.filepath)
  return filepath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* QARequest::release_filepath() {
  // @@protoc_insertion_point(field_release:qa.QARequest.filepath)
  
  return filepath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void QARequest::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  filepath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filepath);
  // @@protoc_insertion_point(field_set_allocated:qa.QARequest.filepath)
}

// -------------------------------------------------------------------

// QAReply

// bool isOk = 1;
inline void QAReply::clear_isok() {
  isok_ = false;
}
inline bool QAReply::isok() const {
  // @@protoc_insertion_point(field_get:qa.QAReply.isOk)
  return isok_;
}
inline void QAReply::set_isok(bool value) {
  
  isok_ = value;
  // @@protoc_insertion_point(field_set:qa.QAReply.isOk)
}

// -------------------------------------------------------------------

// QARequest2

// string content = 1;
inline void QARequest2::clear_content() {
  content_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& QARequest2::content() const {
  // @@protoc_insertion_point(field_get:qa.QARequest2.content)
  return content_.GetNoArena();
}
inline void QARequest2::set_content(const std::string& value) {
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qa.QARequest2.content)
}
inline void QARequest2::set_content(std::string&& value) {
  
  content_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qa.QARequest2.content)
}
inline void QARequest2::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qa.QARequest2.content)
}
inline void QARequest2::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qa.QARequest2.content)
}
inline std::string* QARequest2::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:qa.QARequest2.content)
  return content_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* QARequest2::release_content() {
  // @@protoc_insertion_point(field_release:qa.QARequest2.content)
  
  return content_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void QARequest2::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:qa.QARequest2.content)
}

// -------------------------------------------------------------------

// QAReply2

// int32 index = 1;
inline void QAReply2::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 QAReply2::index() const {
  // @@protoc_insertion_point(field_get:qa.QAReply2.index)
  return index_;
}
inline void QAReply2::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:qa.QAReply2.index)
}

// -------------------------------------------------------------------

// wordVector

// string word = 1;
inline void wordVector::clear_word() {
  word_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& wordVector::word() const {
  // @@protoc_insertion_point(field_get:qa.wordVector.word)
  return word_.GetNoArena();
}
inline void wordVector::set_word(const std::string& value) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qa.wordVector.word)
}
inline void wordVector::set_word(std::string&& value) {
  
  word_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qa.wordVector.word)
}
inline void wordVector::set_word(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qa.wordVector.word)
}
inline void wordVector::set_word(const char* value, size_t size) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qa.wordVector.word)
}
inline std::string* wordVector::mutable_word() {
  
  // @@protoc_insertion_point(field_mutable:qa.wordVector.word)
  return word_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* wordVector::release_word() {
  // @@protoc_insertion_point(field_release:qa.wordVector.word)
  
  return word_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void wordVector::set_allocated_word(std::string* word) {
  if (word != nullptr) {
    
  } else {
    
  }
  word_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:qa.wordVector.word)
}

// repeated float score = 2;
inline int wordVector::score_size() const {
  return score_.size();
}
inline void wordVector::clear_score() {
  score_.Clear();
}
inline float wordVector::score(int index) const {
  // @@protoc_insertion_point(field_get:qa.wordVector.score)
  return score_.Get(index);
}
inline void wordVector::set_score(int index, float value) {
  score_.Set(index, value);
  // @@protoc_insertion_point(field_set:qa.wordVector.score)
}
inline void wordVector::add_score(float value) {
  score_.Add(value);
  // @@protoc_insertion_point(field_add:qa.wordVector.score)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
wordVector::score() const {
  // @@protoc_insertion_point(field_list:qa.wordVector.score)
  return score_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
wordVector::mutable_score() {
  // @@protoc_insertion_point(field_mutable_list:qa.wordVector.score)
  return &score_;
}

// -------------------------------------------------------------------

// wordVectorList

// repeated .qa.wordVector wVec = 1;
inline int wordVectorList::wvec_size() const {
  return wvec_.size();
}
inline void wordVectorList::clear_wvec() {
  wvec_.Clear();
}
inline ::qa::wordVector* wordVectorList::mutable_wvec(int index) {
  // @@protoc_insertion_point(field_mutable:qa.wordVectorList.wVec)
  return wvec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::wordVector >*
wordVectorList::mutable_wvec() {
  // @@protoc_insertion_point(field_mutable_list:qa.wordVectorList.wVec)
  return &wvec_;
}
inline const ::qa::wordVector& wordVectorList::wvec(int index) const {
  // @@protoc_insertion_point(field_get:qa.wordVectorList.wVec)
  return wvec_.Get(index);
}
inline ::qa::wordVector* wordVectorList::add_wvec() {
  // @@protoc_insertion_point(field_add:qa.wordVectorList.wVec)
  return wvec_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::wordVector >&
wordVectorList::wvec() const {
  // @@protoc_insertion_point(field_list:qa.wordVectorList.wVec)
  return wvec_;
}

// -------------------------------------------------------------------

// sentenceVector

// repeated float score = 1;
inline int sentenceVector::score_size() const {
  return score_.size();
}
inline void sentenceVector::clear_score() {
  score_.Clear();
}
inline float sentenceVector::score(int index) const {
  // @@protoc_insertion_point(field_get:qa.sentenceVector.score)
  return score_.Get(index);
}
inline void sentenceVector::set_score(int index, float value) {
  score_.Set(index, value);
  // @@protoc_insertion_point(field_set:qa.sentenceVector.score)
}
inline void sentenceVector::add_score(float value) {
  score_.Add(value);
  // @@protoc_insertion_point(field_add:qa.sentenceVector.score)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
sentenceVector::score() const {
  // @@protoc_insertion_point(field_list:qa.sentenceVector.score)
  return score_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
sentenceVector::mutable_score() {
  // @@protoc_insertion_point(field_mutable_list:qa.sentenceVector.score)
  return &score_;
}

// -------------------------------------------------------------------

// sentenceVectorList

// repeated .qa.sentenceVector sVec = 1;
inline int sentenceVectorList::svec_size() const {
  return svec_.size();
}
inline void sentenceVectorList::clear_svec() {
  svec_.Clear();
}
inline ::qa::sentenceVector* sentenceVectorList::mutable_svec(int index) {
  // @@protoc_insertion_point(field_mutable:qa.sentenceVectorList.sVec)
  return svec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::sentenceVector >*
sentenceVectorList::mutable_svec() {
  // @@protoc_insertion_point(field_mutable_list:qa.sentenceVectorList.sVec)
  return &svec_;
}
inline const ::qa::sentenceVector& sentenceVectorList::svec(int index) const {
  // @@protoc_insertion_point(field_get:qa.sentenceVectorList.sVec)
  return svec_.Get(index);
}
inline ::qa::sentenceVector* sentenceVectorList::add_svec() {
  // @@protoc_insertion_point(field_add:qa.sentenceVectorList.sVec)
  return svec_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::sentenceVector >&
sentenceVectorList::svec() const {
  // @@protoc_insertion_point(field_list:qa.sentenceVectorList.sVec)
  return svec_;
}

// -------------------------------------------------------------------

// docFreqVector

// string word = 1;
inline void docFreqVector::clear_word() {
  word_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& docFreqVector::word() const {
  // @@protoc_insertion_point(field_get:qa.docFreqVector.word)
  return word_.GetNoArena();
}
inline void docFreqVector::set_word(const std::string& value) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qa.docFreqVector.word)
}
inline void docFreqVector::set_word(std::string&& value) {
  
  word_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qa.docFreqVector.word)
}
inline void docFreqVector::set_word(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qa.docFreqVector.word)
}
inline void docFreqVector::set_word(const char* value, size_t size) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qa.docFreqVector.word)
}
inline std::string* docFreqVector::mutable_word() {
  
  // @@protoc_insertion_point(field_mutable:qa.docFreqVector.word)
  return word_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* docFreqVector::release_word() {
  // @@protoc_insertion_point(field_release:qa.docFreqVector.word)
  
  return word_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void docFreqVector::set_allocated_word(std::string* word) {
  if (word != nullptr) {
    
  } else {
    
  }
  word_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:qa.docFreqVector.word)
}

// float freq = 2;
inline void docFreqVector::clear_freq() {
  freq_ = 0;
}
inline float docFreqVector::freq() const {
  // @@protoc_insertion_point(field_get:qa.docFreqVector.freq)
  return freq_;
}
inline void docFreqVector::set_freq(float value) {
  
  freq_ = value;
  // @@protoc_insertion_point(field_set:qa.docFreqVector.freq)
}

// -------------------------------------------------------------------

// docFreqVectorList

// repeated .qa.docFreqVector idf = 1;
inline int docFreqVectorList::idf_size() const {
  return idf_.size();
}
inline void docFreqVectorList::clear_idf() {
  idf_.Clear();
}
inline ::qa::docFreqVector* docFreqVectorList::mutable_idf(int index) {
  // @@protoc_insertion_point(field_mutable:qa.docFreqVectorList.idf)
  return idf_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docFreqVector >*
docFreqVectorList::mutable_idf() {
  // @@protoc_insertion_point(field_mutable_list:qa.docFreqVectorList.idf)
  return &idf_;
}
inline const ::qa::docFreqVector& docFreqVectorList::idf(int index) const {
  // @@protoc_insertion_point(field_get:qa.docFreqVectorList.idf)
  return idf_.Get(index);
}
inline ::qa::docFreqVector* docFreqVectorList::add_idf() {
  // @@protoc_insertion_point(field_add:qa.docFreqVectorList.idf)
  return idf_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docFreqVector >&
docFreqVectorList::idf() const {
  // @@protoc_insertion_point(field_list:qa.docFreqVectorList.idf)
  return idf_;
}

// -------------------------------------------------------------------

// docIdVector

// string word = 1;
inline void docIdVector::clear_word() {
  word_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& docIdVector::word() const {
  // @@protoc_insertion_point(field_get:qa.docIdVector.word)
  return word_.GetNoArena();
}
inline void docIdVector::set_word(const std::string& value) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qa.docIdVector.word)
}
inline void docIdVector::set_word(std::string&& value) {
  
  word_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qa.docIdVector.word)
}
inline void docIdVector::set_word(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qa.docIdVector.word)
}
inline void docIdVector::set_word(const char* value, size_t size) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qa.docIdVector.word)
}
inline std::string* docIdVector::mutable_word() {
  
  // @@protoc_insertion_point(field_mutable:qa.docIdVector.word)
  return word_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* docIdVector::release_word() {
  // @@protoc_insertion_point(field_release:qa.docIdVector.word)
  
  return word_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void docIdVector::set_allocated_word(std::string* word) {
  if (word != nullptr) {
    
  } else {
    
  }
  word_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:qa.docIdVector.word)
}

// repeated int32 docId = 2;
inline int docIdVector::docid_size() const {
  return docid_.size();
}
inline void docIdVector::clear_docid() {
  docid_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 docIdVector::docid(int index) const {
  // @@protoc_insertion_point(field_get:qa.docIdVector.docId)
  return docid_.Get(index);
}
inline void docIdVector::set_docid(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  docid_.Set(index, value);
  // @@protoc_insertion_point(field_set:qa.docIdVector.docId)
}
inline void docIdVector::add_docid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  docid_.Add(value);
  // @@protoc_insertion_point(field_add:qa.docIdVector.docId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
docIdVector::docid() const {
  // @@protoc_insertion_point(field_list:qa.docIdVector.docId)
  return docid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
docIdVector::mutable_docid() {
  // @@protoc_insertion_point(field_mutable_list:qa.docIdVector.docId)
  return &docid_;
}

// -------------------------------------------------------------------

// docIdVectorList

// repeated .qa.docIdVector dIdVec = 1;
inline int docIdVectorList::didvec_size() const {
  return didvec_.size();
}
inline void docIdVectorList::clear_didvec() {
  didvec_.Clear();
}
inline ::qa::docIdVector* docIdVectorList::mutable_didvec(int index) {
  // @@protoc_insertion_point(field_mutable:qa.docIdVectorList.dIdVec)
  return didvec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docIdVector >*
docIdVectorList::mutable_didvec() {
  // @@protoc_insertion_point(field_mutable_list:qa.docIdVectorList.dIdVec)
  return &didvec_;
}
inline const ::qa::docIdVector& docIdVectorList::didvec(int index) const {
  // @@protoc_insertion_point(field_get:qa.docIdVectorList.dIdVec)
  return didvec_.Get(index);
}
inline ::qa::docIdVector* docIdVectorList::add_didvec() {
  // @@protoc_insertion_point(field_add:qa.docIdVectorList.dIdVec)
  return didvec_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qa::docIdVector >&
docIdVectorList::didvec() const {
  // @@protoc_insertion_point(field_list:qa.docIdVectorList.dIdVec)
  return didvec_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace qa

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_qa_2eproto
